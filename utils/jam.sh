#! /bin/sh
# Jam utility: Create self-extracting POSIX shell archives
# Example usage:
#   ./jam.sh file1 file2 dir1 dir2
#
# Options:
#   -v, --verbose: Enable verbose output
#   -b, --binary: Treat all files as binary (default recognizes .bin, .tar, .gz, .exe files as binary)
#   --eof: Specify a custom end-of-file separator (default is EOF3141592653)


set -e -u

log() {
  if [ $opt_verbose -eq 1 ]; then
    printf "$@\n" >&2
  fi
}

warn() {
  printf "%s\n" "$1" >&2
}

error() {
  printf "Error: %s\n" "$1" >&2
  exit 1
}

EOF_SEP="EOF3141592653"
BINARY_EXTS="bin|tar|gz|exe||"

opt_all_binary=0
opt_verbose=0

files_to_extract=""
use_pcat=0
use_bin_decode=0

# Parse options
while [ $# -gt 1 ]; do
  case "$1" in
    -v|--verbose)
      opt_verbose=1
      shift
      ;;
    -b|--binary)
      opt_all_binary=1
      shift
      ;;
    --eof)
      if [ $# -lt 2 ]; then
        error "Missing argument for --eof option."
      fi
      EOF_SEP="$2"
      shift 2
      ;;
    "-"*) error "Unknown option '$1'";;
    *) break ;;
  esac
done

# Replace every non-alphanumeric character with _
# POSIX equivalent to printf "%s" "$1" | sed 's/[^a-zA-Z0-9]/_/g'
normalize_name() { # $1: name to normalize
  name="${1}"
  normalized_name=""
  while [ -n "$name" ]; do
    char="${name%"${name#?}"}" # Get the first character
    name="${name#?}"           # Remove the first character
    case "$char" in
      [a-zA-Z0-9]) normalized_name="${normalized_name}${char}" ;;
      *)           normalized_name="${normalized_name}_" ;;
    esac
  done
  printf "%s" "$normalized_name"
}

is_bin_file_ext() { # $1: file extension
  IFS="|"
  for ext in $BINARY_EXTS; do
    [ "$1" = "$ext" ] && return 0
  done

  return 1
}

gen_header() {
  # Should we add the files contained in the archive and their hashes?
  printf "# This file was generated by $0\n"
  printf "\n"
}

pcat() {
  IFS=
  while read -r line; do
    printf "%s\n" "$line"
  done

  if [ -n "$line" ]; then
    printf "%s" "$line"
  fi
  [ -z "$line" ] # Return if the last character is a newline
}

gen_pcat() {
  pcat << 'EOF'
pcat() {
  IFS=
  while read -r line; do
    printf "%s\n" "$line"
  done
  if [ -n "$line" ]; then
    printf "%s" "$line"
  fi
  [ -z "$line" ] # Return if the last character is a newline
}

EOF
}

gen_bin_decode() {
  pcat << 'EOF'
# Initialize character codes for base64 decoding
b64_chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
b64_plus=62
b64_slash=63
ix=0
while [ -n "$b64_chars" ]; do
    rest="${b64_chars#?}"
    char="${b64_chars%"$rest"}"
    b64_chars="$rest"
    : $(( b64_$char = (ix += 1) - 1 ))
done

# Update accumulator with base64 character code
acc=0
count=0
base64_update() {
  case "$1" in
    [a-zA-Z0-9]) : $(( acc = (acc << 6) + b64_$1 )) ;;
    "+")         : $(( acc = (acc << 6) + b64_plus )) ;;
    "/")         : $(( acc = (acc << 6) + b64_slash )) ;;
    "=") return 1 ;; # End of data, do not process '='. Bits from padding do not terminate the last byte.
    *)   printf "Invalid base64 character: '$1'\n"; exit 1 ;;
  esac
  return 0
}

decode_bin_line() {
  while [ ! -z "$line" ]; do
    tail="${line#?}"
    char="${line%"$tail"}"
    line="$tail"                      # Remove the first character
    base64_update "$char" || break    # Get character code or break on end
    count=$((count + 6))              # Number of bits processed
    if [ $count -ge 8 ]; then
      count=$((count - 8))            # Reduce the count by 8 bits
      byte=$((acc >> count))          # Get the byte from the accumulator
      printf "\\$(($byte/64))$((($byte/8)%8))$((($byte%8)))"
      acc=$((acc & ((1 << count) - 1)))  # Keep the remaining bits in the accumulator
    fi
  done
}

decode_bin() {
  acc=0
  count=0
  IFS=
  while read -r line; do
    decode_bin_line "$line"
  done
}

EOF
}

extract_fun_start() { # $1: file name, $2: normalized file name
  printf "extract_%s() {\n" "$2"
  file_path="${1%/*}" # Remove everything after the last slash, if any
  if [ -n "$file_path" ] && [ "$1" != "$file_path" ]; then
    printf "  mkdir -p '%s' > /dev/null 2>&1 || { printf \"Skipping file %s (no mkdir)\\\\n\"; return 1; }\n" "$file_path" "$1"
  fi
  printf "  printf \"Extracting %s\\\\n\"\n" "$1"
}

extract_fun_end() {
  printf "}\n\n"

  files_to_extract="$files_to_extract $1"
}

process_file() { # $1: file to process, $2: path
  normalized_name="$(normalize_name "${2:-$1}")"
  extension="${1##*.}" # Get the file extension by removing everything before the last dot
  [ "$1" = "$extension" ] && extension="" # If there's no dot, set extension to empty
  log "Processing file '$1' => '$normalized_name'."

  extract_fun_start "${2:-$1}" "$normalized_name"

  if [ $opt_all_binary -ne 0 ] || is_bin_file_ext "$extension"; then
    log "Processing binary file '$1'."
    use_bin_decode=1
    printf "  decode_bin << '%s' > %s\n" "$EOF_SEP" "${2:-$1}"
    base64 -w 80 < "$1"
    printf "%s\n" "$EOF_SEP"
  else
    log "Processing text file '$1'."
    # For some reason, we cannot redirect the heredoc directly to a file
    # descriptor If we could, we'd be able to skip the pcat function and just
    # use the heredoc directly like so: `{fd}<< EOF ... EOF`
    use_pcat=1
    printf "  pcat << '%s' > %s\n" "$EOF_SEP" "${2:-$1}"
    pcat "$1" < "$1" || {
      log "Warning: Last line does not end with a newline, adding it."
      printf "\n"
    }
    printf "%s\n" "$EOF_SEP"
  fi
  extract_fun_end "$normalized_name"
}

process_dir() { # $1: directory to process
  log "Processing directory '$1'."
  IFS=" "
  for file in "$1"/*; do
    if [ -f "$file" ]; then
      process_file "$file"
    elif [ -d "$file" ]; then
      process_dir "$file"
    else
      warn "Skipping '$file': not a file or directory."
    fi
  done
}

gen_header

# Loop over the arguments, if it's a file, then
for arg in "$@"; do
  # if the file has a ':' character in it, overwrite the path with whatever is after the ':'
  path=${arg##*:}
  if [ "$path" != "$arg" ]; then
    log "Overwriting path: $arg -> $path"
    arg=${arg%:*} # Remove ':$path'
  else
    path=""
  fi
  if [ -f "$arg" ]; then
    process_file "$arg" "$path"
  elif [ -d "$arg" ]; then
    process_dir "$arg"
  else
    warn "Skipping '$arg': not a file or directory."
  fi
done

# Add the pcat and uudecode functions if they are needed
[ $use_pcat = 1 ] && gen_pcat
[ $use_bin_decode = 1 ] && gen_bin_decode

IFS=" "
for func in $files_to_extract; do
  printf "extract_%s\n" "$func"
done
