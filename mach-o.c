// Minimal Mach-O header for 32-bit and 64-bit architectures.
// https://stackoverflow.com/questions/32453849/minimal-mach-o-64-binary/32659692#32659692

#ifdef ONE_PASS_GENERATOR
#error "Mach-O generation not supported in one-pass mode"
#endif

// Size: 8 * 4 bytes = 32 bytes
void write_mach_o_header_64() {
  write_4_i8(0xcf, 0xfa, 0xed, 0xfe); // magic number (MH_MAGIC_64)
  write_4_i8(0x07, 0x00, 0x00, 0x01); // CPU type (CPU_TYPE_X86_64)
  write_4_i8(0x03, 0x00, 0x00, 0x80); // CPU subtype (CPU_SUBTYPE_X86_64_ALL)
  write_4_i8(0x02, 0x00, 0x00, 0x00); // file type (MH_EXECUTE)
  write_4_i8(0x03, 0x00, 0x00, 0x00); // number of load commands
  write_4_i8(0x48, 0x01, 0x00, 0x00); // size of all load commands
  write_4_i8(0x01, 0x00, 0x00, 0x00); // flags
  write_4_i8(0x00, 0x00, 0x00, 0x00); // reserved
}

// Size: 18 * 4 bytes = 72 bytes
void write_pagezero() {
  write_4_i8(0x19, 0x00, 0x00, 0x00); // LC_SEGMENT_64 ; 4 bytes
  write_4_i8(0x48, 0x00, 0x00, 0x00); // command size ; 4 bytes
  write_4_i8(0x5f, 0x5f, 0x50, 0x41); // segment name ; 16 bytes
  write_4_i8(0x47, 0x45, 0x5a, 0x45); // segment name (cont.)
  write_4_i8(0x52, 0x4f, 0x00, 0x00); // segment name (cont.)
  write_4_i8(0x00, 0x00, 0x00, 0x00); // segment name (cont.)
  write_4_i8(0x00, 0x00, 0x00, 0x00); // VM address ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // VM address (cont.)
  write_4_i8(0x00, 0x00, 0x00, 0x00); // VM size ; 8 bytes
  write_4_i8(0x01, 0x00, 0x00, 0x00); // VM size (cont.)
  write_4_i8(0x00, 0x00, 0x00, 0x00); // file offset ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // file offset (cont.)
  write_4_i8(0x00, 0x00, 0x00, 0x00); // file size ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // file size (cont.)
  write_4_i8(0x00, 0x00, 0x00, 0x00); // max VM protection ; 4 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // initial VM protection ; 4 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // number of sections ; 4 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // flags ; 4 bytes
}

// Size: 18 * 4 bytes = 72 bytes
void write_text_section() {
  write_4_i8(0x19, 0x00, 0x00, 0x00); // LC_SEGMENT_64 ; 4 bytes
  write_4_i8(0x48, 0x00, 0x00, 0x00); // command size ; 4 bytes
  write_4_i8(0x5f, 0x5f, 0x54, 0x45); // segment name ; 16 bytes
  write_4_i8(0x58, 0x54, 0x00, 0x00); // segment name (cont.)
  write_4_i8(0x00, 0x00, 0x00, 0x00); // segment name (cont.)
  write_4_i8(0x00, 0x00, 0x00, 0x00); // segment name (cont.)

  write_i32_le(0x00000000); // VM address low
  write_i32_le(0x00000001); // VM address high
  write_i32_le(code_alloc + 360); // VM size low. 360 is the size of the mach-o header
  write_i32_le(0x00000000); // VM size high. Warning: This assumes that the file size is less than 4GB
  write_i32_le(0x00000000); // file offset low
  write_i32_le(0x00000000); // file offset high
  write_i32_le(code_alloc + 360); // file size low. 360 is the size of the mach-o header
  write_i32_le(0x00000000); // file size high. Warning: This assumes that the file size is less than 4GB

  write_4_i8(0x07, 0x00, 0x00, 0x00); // max VM protection ; 4 bytes
  write_4_i8(0x05, 0x00, 0x00, 0x00); // initial VM protection ; 4 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // number of sections ; 4 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // flags ; 4 bytes
}

// Size: 46 * 4 bytes = 184 bytes
void write_unix_thread() {
  write_4_i8(0x05, 0x00, 0x00, 0x00); // LC_UNIXTHREAD
  write_4_i8(0xb8, 0x00, 0x00, 0x00); // command size ; 4 bytes
  write_4_i8(0x04, 0x00, 0x00, 0x00); // flavor ; 4 bytes
  write_4_i8(0x2a, 0x00, 0x00, 0x00); // count ; 4 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RAX ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RBX ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RCX ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RDX ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RDI ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RSI ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RBP ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RSP ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // R8 ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // R9 ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // R10 ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // R11 ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // R12 ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // R13 ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // R14 ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // R15 ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x68, 0x01, 0x00, 0x00); // RIP ; 8 bytes
  write_4_i8(0x01, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // RFLAGS ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // CS ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // FS ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
  write_4_i8(0x00, 0x00, 0x00, 0x00); // GS ; 8 bytes
  write_4_i8(0x00, 0x00, 0x00, 0x00);
}

void generate_exe() {
  int i = 0;
  int file_size = code_alloc;

  write_mach_o_header_64();
  write_pagezero();
  write_text_section();
  write_unix_thread();

  while (i < code_alloc) {
    write_i8(code[i]);
    i += 1;
  }

  // Fill the rest of the file with zeros (Mach-O files must be at least 4096 bytes)
  while (file_size < 4096) {
    write_i8(0x00);
    file_size += 1;
  }
}
